import * as React from 'react';
import ReactAutocomplete from 'react-autocomplete';
import { InputPropTypes, ItemShape } from 'inputs/prop-types';

/**
 * Represents a text input component that additionally renders a list of
 * autocomplete items below the text input when the user is typing.
 */
export default React.createClass({
  displayName: 'Autocomplete',

  propTypes: Object.assign({}, InputPropTypes, {
    /**
     * Allows styling of the <input /> element of this Autocomplete component.
     *
     * This is useful to fix border-radius when used together with a bootstrap
     * input-group-addon.
     */
    autoCompleteStyle: React.PropTypes.object,

    /**
     * The collection of valid values.
     */
    items: React.PropTypes.arrayOf(ItemShape).isRequired,

    /**
     * The text displayed when the <input /> element is empty.
     */
    placeholder: React.PropTypes.string,

    value: React.PropTypes.string,
  }),

  getInitialState() {
    return this.getStateFromProps(this.props, false);
  },

  /**
   * Updates the state of this Autocomplete component when the specified
   * value changes from the last props update. This way it is possible
   * to change the value through the props and still have internal
   * value state.
   *
   * @param {object} nextProps
   */
  componentWillReceiveProps(nextProps) {
    this.setState(this.getStateFromProps(nextProps));
  },

  /**
   * Computes the label from the given value.
   *
   * @param {string} value
   * @param {{ label: string, value: string }[]} items
   * @returns {string} the label if it could be computed; otherwise the value
   */
  getLabelFromValue(value, items) {
    const currentValue = items.find(item => item.value === value);
    return (currentValue && currentValue.label) || value;
  },

  getStateFromProps(props, checkCurrentState = true) {
    let state = {};
    if (!checkCurrentState || this.state.givenValue !== props.value) {
      const items = props.items || this.props.items;
      state = {
        givenValue: props.value || '',
        realValue: this.getLabelFromValue(props.value, items)
      };
    }
    return state;
  },

  handleChange(e, value) {
    this.setState({ realValue: value }, this.maybeEmitValueChange);
  },

  handleSelect(value) {
    this.setState({ realValue: value }, this.maybeEmitValueChange);
  },

  maybeEmitValueChange() {
    const { items, name, onValueChange } = this.props;
    const value = items.find(i => i.label === this.state.realValue);
    if (value) {
      onValueChange(name, value.value, true);
    }
  },

  shouldItemRender(item, value) {
    return item.label.toLowerCase().indexOf(value.toLowerCase()) >= 0;
  },

  renderItem(item, isHighlighted) {
    const style = {
      background: isHighlighted ? 'rgb(244, 249, 253)' : 'white',
      padding: '4px 8px',
    };

    return (
      <div style={style} key={item.value}>{item.label}</div>
    );
  },

  render() {
    return (
      <ReactAutocomplete
        wrapperStyle={{}}
        menuStyle={{
          borderRadius: '3px',
          boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
          background: 'rgba(255, 255, 255, 0.9)',
          padding: '2px 0',
          fontSize: '90%',
          position: 'fixed',
          overflow: 'auto',
          maxHeight: '50%',
          zIndex: 10,
        }}
        value={this.state.realValue}
        inputProps={{
          className: 'form-control',
          id: this.props.id,
          placeholder: this.props.placeholder,
          style: this.props.autoCompleteStyle,
        }}
        items={this.props.items}
        getItemValue={(item) => item.label}
        shouldItemRender={this.shouldItemRender}
        onChange={this.handleChange}
        onSelect={this.handleSelect}
        renderItem={this.renderItem}
      />
    );
  }
});

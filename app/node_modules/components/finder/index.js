import * as React from 'react';
import { debounce } from 'lodash';
import Alert from 'components/alert';
import Button from 'components/button';
import ItemsControl from 'components/items-control';
import SearchForm from './search-form';
import HeaderControl from './header-control';
import { translate } from 'config/strings';


const OUTDATED_REQUEST = {
  message: '__OUTDATED_REQUEST',
};


/**
 * Responsible for providing the UI and UX for finder pages.
 *
 * Consists of a search form and an items control.
 */
export default React.createClass({
  displayName: 'Finder',

  propTypes: {
    /**
     * Number of items that is fetched when loading data.
     */
    batchSize: React.PropTypes.number,

    /**
     * The column titles for the header.
     */
    columns: React.PropTypes.arrayOf(
      React.PropTypes.shape({
        label: React.PropTypes.string,
        props: React.PropTypes.object,
      }).isRequired
    ).isRequired,

    /**
     * A function used by the finder to fetch items. The function is expected
     * to return a promise.
     *
     * Parameters:
     *  - skip: number
     *  - batchSize: number
     *  - config: object
     *
     * This function should return a Promise:
     *  - resolve:
     *    - data: { data: [{...}], total: number }
     *  - reject:
     *    - error: { message: string }
     */
    fetchData: React.PropTypes.func.isRequired,

    /**
     * Signals to the finder to update its search results.
     *
     * This is useful when the search config is updated from outside the finder.
     */
    reloadToken: React.PropTypes.any,

    /**
     * @see ./search-form.js
     */
    searchConfig: React.PropTypes.array.isRequired,

    /**
     * Finder does not store state internally, but let the parent decide how
     * and where to store it. For this, the parent has to provide a State
     * Container.
     *
     * This way, the parent can decide whether to store the whole or certain
     * parts of the state in the url (i.e. query params) or somewhere else.
     */
    state: React.PropTypes.shape({
      /**
       * Called when a clear-filters action is invoked by the user.
       */
      clear: React.PropTypes.func.isRequired,

      /**
       * Used to retrieve the current state.
       */
      get: React.PropTypes.func.isRequired,

      /**
       * Used to update the current state.
       *
       * Parameters:
       *  - newState: object
       */
      update: React.PropTypes.func.isRequired,
    }).isRequired,
  },

  getDefaultProps() {
    return {
      batchSize: 50,
    };
  },

  getInitialState: () => ({
    error: null,
    items: [],
    loading: false,
    total: 1000, // --> Finder assumes there's something to load
  }),

  componentDidMount() {
    // to prevent attempt to update state after component is unmounted
    // see: didLoadMoreData
    this._isMounted = true;
    this.loadMore();
  },

  componentWillReceiveProps(nextProps) {
    if (this.props.reloadToken !== nextProps.reloadToken) {
      this.loadNew();
    }
  },

  componentWillUnmount() {
    this._isMounted = false;
  },

  _isMounted: false,
  _reqId: 0,

  loadData(skip, batchSize) {
    return new Promise((resolve, reject) => {
      const myReqId = ++this._reqId;
      this.setState({ loading: true }, () => {
        const delay = Math.floor(Math.random() * 1000);
        setTimeout(() => {
          this.props.fetchData(skip, batchSize, this.props.state.get())
            .then(data => {
              if (myReqId === this._reqId) {
                resolve(data);
              } else {
                reject(OUTDATED_REQUEST);
              }
            })
            .catch(reason => {
              if (myReqId === this._reqId) {
                reject(reason);
              } else {
                reject(OUTDATED_REQUEST);
              }
            });
        }, delay);
      });
    });
  },

  loadMore() {
    const { loading, items, total } = this.state;
    const batchSize = this.props.batchSize;
    if (!loading && total > items.length) {
      this.loadData(items && items.length || 0, batchSize)
        .then(this.didLoadMoreData)
        .catch(this.didEncounterProblem);
    }
  },

  /**
   * Debounced version of loading new data. This allows users to further
   * specify what data should be loaded (i.e. write in a search field) without
   * sending multiple API requests.
   */
  loadNewDebounced: debounce((loadData, batchSize, resolve, reject) => {
    loadData(0, batchSize).then(resolve).catch(reject);
  }, 200, { leading: false, trailing: true }),

  loadNew() {
    this.loadNewDebounced(
      this.loadData,
      this.props.batchSize,
      this.didLoadNewData,
      this.didEncounterProblem
    );
  },

  didLoadMoreData(response) {
    this.setStateIfMounted({
      loading: false,
      error: null,
      items: [...this.state.items, ...response.data],
      total: response.total,
    });
  },

  didLoadNewData(response) {
    this.setStateIfMounted({
      loading: false,
      error: null,
      items: [...response.data],
      total: response.total,
    });
  },

  setStateIfMounted(newState) {
    if (this._isMounted) {
      this.setState(newState);
    }
  },

  didEncounterProblem(response) {
    if (response !== OUTDATED_REQUEST && this._isMounted) {
      this.setState({
        loading: false,
        error: response.message
      });
    }
  },

  /**
   * Called if this finder is linked to an event through tapEvent(..).
   * See: helpers/tap-event module
   */
  handleTappedEvent(e) {
    const { clientHeight, scrollHeight, scrollTop } = e.target;
    const threshold = scrollHeight - clientHeight - scrollTop;
    if (threshold < 150) {
      this.loadMore();
    }
  },

  handleAction(action) {
    if (action === 'submit') {
      this.loadNew();
    } else if (action === 'clear-filters') {
      this.props.state.clear();
      this.loadNew();
    }
  },

  handleValueChange(key, value/*, isValid*/) {
    this.props.state.update({
      [key]: value,
    });
    this.loadNew();
  },

  /**
   * On huge screens, the initial list might not overflow -> no scrolling
   * Therefore this "load more" button allows loading more items manually.
   */
  renderLoadMoreButton() {
    const { items, total } = this.state;
    if (total <= items.length) {
      return (
        <div className="text-center">
          <Alert type="info" message={translate('finder.no-more')} />
        </div>
      );
    }
    return (
      <div className="text-center">
        <Button
          name="load-more"
          label="Load More"
          onAction={() => this.loadMore()}
          attributes={{
            disabled: !!this.state.loading,
          }}
        />
      </div>
    );
  },

  render() {
    const { error, items } = this.state;
    const { searchConfig } = this.props;
    const state = this.props.state.get();

    const searchValues = { values: {} };
    searchConfig.forEach(c => {
      c.value = state[c.name];
    });

    return (
      <div>
        <SearchForm
          {...this.props}
          {...searchValues}
          onAction={this.handleAction}
          onValueChange={this.handleValueChange}
        />
        <Alert message={error} />
        <div className="table-responsive">
          <table className="table table-bordered table-hover table-condensed">
            <HeaderControl {...this.props} />
            <ItemsControl
              {...this.props}
              items={items}
              wrapperElement="tbody"
            />
          </table>
        </div>
        { this.renderLoadMoreButton() }
      </div>
    );
  }
});

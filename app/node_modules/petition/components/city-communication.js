import * as React from 'react';
import _ from 'lodash';
import Button from 'components/button';
import Card from 'components/card';
import FormNotification from 'components/form-notification';
import TextInput from 'inputs/text';
import MultiLineTextInput from 'inputs/text/multiline';
import { translate } from 'config/strings';
import CityAPI from 'city/api';
import propTypes from './prop-types';
import { apiError } from '../helpers';


const PetitionShape = {
  id: React.PropTypes.string.isRequired,
  city: React.PropTypes.shape({
    id: React.PropTypes.string,
  }).isRequired,
  city_answer: React.PropTypes.shape({
    name: React.PropTypes.string,
    text: React.PropTypes.string
  }),
  supporters: React.PropTypes.shape({
    amount: React.PropTypes.number.isRequired,
  }).isRequired,
};

const responsibleFields = ['city_answer'];


/**
 * Shows and allows editing of information regarding communication with the
 * petitionâ€˜s city.
 *
 * This part of the petition editor is more complicated than for example the
 * basic information part. This comes from having to load and store not only
 * data directly related to the petition but also data related to a city.
 */
export default React.createClass({
  displayName: 'CityCommunication',

  propTypes: Object.assign({}, propTypes(PetitionShape)),

  getInitialState: () => ({
    city: null,
    error: null,
    working: false,
  }),

  componentWillMount() {
    this.fetchCity(this.props.petition.city.id);
  },

  componentWillReceiveProps(nextProps) {
    const cityId = this.props.petition.city && this.props.petition.city.id;
    const nextCityId = nextProps.petition.city && nextProps.petition.city.id;
    if (nextCityId !== cityId) {
      this.fetchCity(nextCityId);
    }
  },

  fetchCity(cityId) {
    if (cityId) {
      CityAPI.get(cityId).then(response => {
        this.setState({ error: null, city: response.data });
      }).catch(response => {
        this.setState({ error: response });
      });
    } else {
      this.setState({ city: null });
    }
  },

  handleCityValueChange(name, value/*, valid*/) {
    const { city } = this.state;
    let contact = Object.assign({}, city.contact, { [name]: value });
    this.setState({
      city: Object.assign({}, city, { contact }),
    });
  },

  handleAction(name) {
    switch (name) {
      case 'save':
        return this.save();
      case 'generate-letter':
        return this.save().then(() => {
          setTimeout(() => {
            const url = window.location.origin + '#/petition/' + this.props.petition.id + '/letter/cover';
            window.open(url);
          }, 0);
        });
      case 'generate-appendix':
        return this.save().then(() => {
          setTimeout(() => {
            const url = window.location.origin + '#/petition/' + this.props.petition.id + '/letter/appendix';
            window.open(url);
          }, 0);
        });
      default:
        return Promise.reject(`No Such Action: "${name}"`);
    }
  },

  save() {
    return new Promise((resolve, reject) => {
      this.setState({ error: null, working: true }, () => {
        const { city } = this.state;
        const savePromises = [
          CityAPI.update(city.id, { contact: city.contact }),
          this.props.onAction('save', responsibleFields),
        ];
        Promise.all(savePromises).then(results => {
          this.setState({ city: results[0].data, working: false });
          resolve();
        }).catch(response => {
          this.setState({ error: apiError(response), working: false });
          reject();
        });
      });
    });
  },

  renderNoCityMessage() {
    return (
      <div className="col-xs-12">
        <FormNotification type="warning">
          {translate('petitions.infos.no-city')}
        </FormNotification>
      </div>
    );
  },

  _inputProps(key) {
    const { city } = this.state;
    return {
      id: key,
      name: key,
      value: city && city.contact[key],
      onValueChange: this.handleCityValueChange,
      attributes: {
        rows: 6,
      },
    };
  },

  renderInput(Component, key) {
    return (
      <div className="col-xs-12" style={{ marginBottom: 12 }}>
        <label htmlFor={key}>{translate(`city.contact.${key}`)}</label>
        <Component {...this._inputProps(key)} />
      </div>
    );
  },

  /**
   * The city response field belongs to the petition. Therefore, the wrapping
   * component (petition editor) should take care of storing and updating the
   * value.
   */
  renderCityResponse() {
    const id = 'city_answer';
    const { petition, onValueChange } = this.props;
    return (
      <div className="col-xs-12" style={{ marginBottom: 12 }}>
        <label htmlFor={id}>{translate(`petition.${id}`)}</label>
        <MultiLineTextInput
          id={id}
          name={id}
          value={_.get(petition, 'city_answer.text')}
          onValueChange={(name, value) => {
            onValueChange(name, Object.assign({}, petition.city_answer, {
              text: value
            }));
          }}
          attributes={{ rows: 10 }}
        />
      </div>
    );
  },

  renderCitySender() {
    const id = 'city_answer.name';
    const { petition, onValueChange } = this.props;
    return (
      <div className="col-xs-12" style={{ marginBottom: 12 }}>
        <label htmlFor={id}>{translate(`petition.${id}`)}</label>
        <TextInput
          id={id}
          name={id}
          onValueChange={(name, value) => {
            onValueChange('city_answer', Object.assign({}, petition.city_answer, {
              name: value
            }));
          }}
          value={_.get(petition, 'city_answer.name')}
        />
      </div>
    );
  },

  getErrorDescription(error) {
    if (typeof error === 'string') {
      return error;
    } else if (error && error.type) {
      return translate(`errors.${error.type}`);
    }
    return translate('errors.unknown');
  },

  renderNotification() {
    const { error } = this.state;
    if (!error) {
      return null;
    }
    return (
      <FormNotification type="error">
        {this.getErrorDescription(error)}
      </FormNotification>
    );
  },

  renderButtons() {
    const { city, working } = this.state;
    const { petition } = this.props;

    const isActionAvailable = (action) => {
      switch (action) {
        case 'generate-letter':
          return city.contact.salutation && city.contact.address;
        case 'generate-appendix':
          return !!petition.supporters.amount;
        default:
          return true;
      }
    };

    const buttonProps = (action) => ({
      label: translate(`petitions.actions.${action}`),
      name: action,
      onAction: this.handleAction,
      attributes: {
        disabled: working || !isActionAvailable(action),
      },
    });

    return (
      <div className="col-xs-12">
        {
          ['save', 'generate-letter', 'generate-appendix'].map(action => (
            <span key={action} style={{ marginRight: 10 }}>
              <Button {...buttonProps(action)} />
            </span>
          ))
        }
      </div>
    );
  },

  render() {
    const { city } = this.state;
    return (
      <Card title={translate('petitions.blocks.city-communication')}>
        <div className="row">
          { city ? null : this.renderNoCityMessage() }
          { city ? this.renderInput(TextInput, 'salutation') : null }
          { city ? this.renderInput(MultiLineTextInput, 'address') : null }
          { city ? this.renderCityResponse() : null }
          { city ? this.renderCitySender() : null }
          { city ? this.renderNotification() : null }
          { city ? this.renderButtons() : null }
        </div>
      </Card>
    );
  }
});

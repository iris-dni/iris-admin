/* eslint-disable react/prop-types, react/no-multi-comp */
import * as React from 'react';
import { withRouter } from 'react-router';
import Helmet from 'react-helmet';
import { getDatePart } from 'helpers/date';
import makePage from 'components/page';
import AutoLoadFinder from 'components/finder/autoload';
import QueryStateContainer from 'helpers/query-state-container';
import RoutingConstants from 'config/routing-constants';
import { translate } from 'config/strings';
import PetitionModel from './model';
import PetitionAPI from './api';


function getData(skip, batchSize, config) {
  const searchParams = Object.assign({
    resolve: ['city', 'owner'].join(','),
    limit: batchSize,
    offset: skip,
  }, config, {
    city: config.city || void 0,
    sort: config.title_ft && 'score' || config.sort || void 0,
    state: config.state || void 0,
    title_ft: config.title_ft || void 0,
  });
  return PetitionAPI.search(searchParams);
}

const openPetitionEditor = (id, router) => {
  router.push(RoutingConstants.PETITION.pathname.replace(':id', id));
};

const columns = [
  { label: translate('petitions.petition') },
  { label: translate('petitions.city') },
  { label: translate('petitions.owner') },
  { label: translate('petitions.supporters') },
  { label: translate('petitions.created') },
  { label: translate('petitions.state') }
];


const ItemsTemplate = ({ item, router }) => {
  const petition = PetitionModel(item);
  if (petition && petition.id) {
    let state = petition.state.name;
    if (petition.state.parent) {
      state = petition.state.parent + '.' + state;
    }
    return (
      <tr
        style={{ cursor: 'pointer' }}
        onClick={() => openPetitionEditor(petition.id, router)}
      >
        <td>{petition.title}</td>
        <td>{petition.city}</td>
        <td>{petition.owner}</td>
        <td>{petition.supporters.count}</td>
        <td>{getDatePart(petition.dc.created)}</td>
        <td>{state}</td>
      </tr>
    );
  }
  return null;
};

export default withRouter(makePage(React.createClass({
  displayName: 'PetitionFinder',

  render() {
    const { location, router } = this.props;
    const title = translate('petitions.finder-title');
    return (
      <div className="container-fluid">
        <Helmet title={title} />
        <h1>{title}</h1>
        <AutoLoadFinder
          reloadToken={location}
          columns={columns}
          fetchData={getData}
          state={QueryStateContainer(location, router, RoutingConstants.PETITIONS.pathname)}
          itemsTemplate={ItemsTemplate}
          itemsTemplateProps={{ router }}
          searchConfig={[
            {
              name: 'title_ft',
              id: 'titleSearchField',
              addon: 'search',
              type: 'string',
              lg: 3,
              md: 6,
              placeholder: 'Title'
            },
            {
              name: 'city',
              id: 'citySearchField',
              addon: 'search',
              type: 'city-autocomplete',
              lg: 3,
              md: 6,
              placeholder: 'City',
              autoCompleteStyle: {
                borderRadius: '0 4px 4px 0',
              },
            },
            {
              name: 'state',
              id: 'statusField',
              type: 'multi-select',
              options: [
                { value: 'draft', label: 'Draft' },
                { value: 'rejected', label: 'Rejected' },
                { value: 'supportable.*', label: 'Supportable' },
                { value: 'supportable.pending', label: 'Pending' },
                { value: 'supportable.active', label: 'Active' },
                { value: 'supportable.winner', label: 'Winner' },
                { value: 'loser', label: 'Loser' },
                { value: 'processing.*', label: 'Processing' },
                { value: 'processing.sendLetterRequested', label: 'Send Letter' },
                { value: 'processing.waitForLetterResponse', label: 'Wait for Letter Response' },
                { value: 'processing.letterResponseArrived', label: 'Letter Response Arrived' },
                { value: 'processing.noLetterResponse', label: 'No Letter Response' },
                { value: 'closedWithoutLetterResponse', label: 'No Letter Closed' },
                { value: 'closed', label: 'Closed' },
                { value: 'deleted', label: 'Deleted' },
              ],
              lg: 6,
            },
            {
              xs: 6,
              name: 'clear-filters',
              label: 'Clear Filters',
              role: 'clear-filters',
            },
            {
              name: 'sort',
              label: 'Sorted by',
              showLabel: true,
              id: 'sortDropdown',
              type: 'options',
              xs: 6,
              pull: 'right',
              options: [
                { value: 'created', label: 'Creation Date' },
                { value: 'trending', label: 'Trending' },
                { value: 'supporters.amount', label: 'Amount Supporters' }
              ],
            }
          ]}
          uniqueItemProperty="id"
        />
      </div>
    );
  }
})));

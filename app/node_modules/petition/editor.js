import * as React from 'react';
import { withRouter } from 'react-router';
import makePage from 'components/page';
import Alert from 'components/alert';
import LoadingIndicator from 'components/loading-indicator';
import PetitionAPI from './api';
import { removeValuesFilter, uniqueFilter } from 'helpers/array';
import extractSubObject from 'helpers/extract-sub-object';
import BasicInfo from './components/basic-info';


/**
 * Shows and allows editing a petition.
 */
export default withRouter(makePage(React.createClass({
  displayName: 'PetitionEditor',

  propTypes: {
    params: React.PropTypes.shape({
      id: React.PropTypes.string.isRequired,
    }).isRequired,
  },

  getInitialState: () => ({
    dirty: [],
    error: null,
    petition: null,
  }),

  componentWillMount() {
    this.fetchPetition(this.props.params.id);
  },

  fetchPetition(id) {
    PetitionAPI.get(id).then((response) => {
      this.setState({
        dirty: [],
        error: null,
        petition: response.data,
      });
    }).catch((response) => {
      this.setState({
        error: response.error && response.error.description,
      });
    });
  },

  handleValueChange(key, value/*, valid*/) {
    this.setState({
      petition: Object.assign({}, this.state.petition, { [key]: value }),
      dirty: [...this.state.dirty, key].filter(uniqueFilter),
    });
  },

  handleAction(action, args) {
    switch (action) {
      case 'save':
        return this.save(args);
      default:
        return Promise.reject(`Petiton Editor: Unknown action "${action}"`);
    }
  },

  /**
   * Saves part of a petition. Returns a promise that is resolved/rejected once
   * saving is completed (either successfully or the action failed).
   *
   * @param {string[]} keys  The properties which should be saved.
   */
  save(keys) {
    return new Promise((resolve, reject) => {
      const { petition } = this.state;
      const partialPetition = {};
      keys.forEach(key => { partialPetition[key] = petition[key]; });
      PetitionAPI.update(petition.id, partialPetition).then(response => {
        // only update the keys that were saved
        const subObject = extractSubObject(response.data, keys);
        this.setState({
          dirty: this.state.dirty.filter(removeValuesFilter(keys)),
          petition: Object.assign({}, this.state.petition, subObject),
        }, () => {
          resolve();
        });
      }).catch(() => {
        reject();
      });
    });
  },

  render() {
    const { error, petition } = this.state;

    if (error) {
      return (
        <div className="container-fluid">
          <Alert message={error} />
        </div>
      );
    } else if (!petition) {
      return <LoadingIndicator />;
    }
    return (
      <div className="container-fluid">
        <BasicInfo
          editable={['draft', 'pending'].indexOf(petition.state.name) >= 0}
          petition={petition}
          onValueChange={this.handleValueChange}
          onAction={this.handleAction}
        />
      </div>
    );
  }
})));

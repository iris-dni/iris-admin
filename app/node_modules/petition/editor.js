import * as React from 'react';
import { withRouter } from 'react-router';
import makePage from 'components/page';
import Alert from 'components/alert';
import LoadingIndicator from 'components/loading-indicator';
import PetitionAPI, { PetitionEventAPI } from './api';
import { apiError, missingProps, unsavedProps, userCancelled } from './helpers';
import { removeValuesFilter, uniqueFilter } from 'helpers/array';
import extractSubObject from 'helpers/extract-sub-object';
import BasicInfo from './components/basic-info';
import StateInfo from './components/state-info';
import UserInfo from './components/user-info';
import CityCommunication from './components/city-communication';
import { translate } from 'config/strings';


/**
 * Shows and allows editing a petition.
 */
export default withRouter(makePage(React.createClass({
  displayName: 'PetitionEditor',

  propTypes: {
    params: React.PropTypes.shape({
      id: React.PropTypes.string.isRequired,
    }).isRequired,
  },

  getInitialState: () => ({
    dirty: [],
    error: null,
    petition: null,
  }),

  componentWillMount() {
    this.fetchPetition(this.props.params.id);
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.params.id !== this.props.params.id) {
      this.fetchPetition(nextProps.params.id);
    }
  },

  fetchPetition(id) {
    PetitionAPI.get(id).then((response) => {
      this.setState({
        dirty: [],
        error: null,
        petition: response.data,
      });
    }).catch((response) => {
      this.setState({
        error: response.error && response.error.description,
      });
    });
  },

  handleValueChange(key, value/*, valid*/) {
    this.setState({
      petition: Object.assign({}, this.state.petition, { [key]: value }),
      dirty: [...this.state.dirty, key].filter(uniqueFilter),
    });
  },

  handleAction(action, args) {
    switch (action) {
      case 'save':
        return this.save(args);
      case 'transition':
        return this.transition(args);
      default:
        return Promise.reject(`Petiton Editor: Unknown action "${action}"`);
    }
  },

  /**
   * Saves part of a petition. Returns a promise that is resolved/rejected once
   * saving is completed (either successfully or the action failed).
   *
   * @param {string[]} keys  The properties which should be saved.
   */
  save(keys) {
    return new Promise((resolve, reject) => {
      const { petition } = this.state;
      const partialPetition = {};
      keys.forEach(key => { partialPetition[key] = petition[key]; });
      PetitionAPI.update(petition.id, partialPetition).then(response => {
        // only update the keys that were saved
        const subObject = extractSubObject(response.data, keys);
        this.setState({
          dirty: this.state.dirty.filter(removeValuesFilter(keys)),
          petition: Object.assign({}, this.state.petition, subObject),
        }, () => {
          resolve();
        });
      }).catch(() => {
        reject();
      });
    });
  },

  // eslint-disable-next-line consistent-return
  checkTransitionVetos(transitionName) {
    const { dirty, petition } = this.state;

    if (dirty && dirty.length > 0) {
      return unsavedProps(dirty);
    }

    if (transitionName === 'approved' && !petition.city) {
      return missingProps(['city']);
    }

    if (transitionName === 'delete') {
      // eslint-disable-next-line no-alert
      if (!confirm(translate('petitions.actions.delete.confirm'))) {
        return userCancelled();
      }
    }
  },

  /**
   * Triggers a state transition.
   *
   * State transitions are only triggered if the current petition is saved (i.e.
   * not dirty).
   * Further transition-specific requirements are possible.
   */
  transition(name) {
    return new Promise((resolve, reject) => {
      let veto = this.checkTransitionVetos(name);
      if (veto) {
        reject(veto);
      } else {
        let data;
        if (name === 'reject') {
          data = {
            message: '',
            notify: true,
          };
        }
        PetitionEventAPI.trigger(this.state.petition.id, name, data).then((response) => {
          this.setState({
            petition: response.data,
          });
          resolve();
        }).catch((response) => {
          reject(apiError(response));
        });
      }
    });
  },

  render() {
    const { error, petition } = this.state;

    if (error) {
      return (
        <div className="container-fluid">
          <Alert message={error} />
        </div>
      );
    } else if (!petition) {
      return <LoadingIndicator />;
    }

    const blockProps = {
      petition: petition,
      onValueChange: this.handleValueChange,
      onAction: this.handleAction,
    };

    return (
      <div className="container-fluid">
        <StateInfo {...blockProps} />
        <BasicInfo
          {...blockProps}
          editable={['draft', 'pending'].indexOf(petition.state.name) >= 0}
        />
        <UserInfo {...blockProps} />
        <CityCommunication {...blockProps} />
      </div>
    );
  }
})));
